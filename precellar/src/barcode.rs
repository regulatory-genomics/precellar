use anyhow::{bail, Result};
use indexmap::IndexMap;
use indicatif::{ProgressBar, ProgressDrawTarget, ProgressIterator, ProgressStyle};
use itertools::Itertools;
use log::info;
use noodles::sam::alignment::{
    record::data::field::{Tag, Value},
    Record,
};
use rand::distr::{slice::Choose, Distribution};
use seqspec::{Assay, Modality, RegionId};
use std::{
    collections::HashMap,
    ops::{Deref, DerefMut},
};
use crate::utils::{rev_compl};

const BC_MAX_QV: u8 = 66; // This is the illumina quality value
pub(crate) const BASE_OPTS: [u8; 4] = [b'A', b'C', b'G', b'T'];

/// Count barcodes in a given assay and modality, returning a map of region IDs to their respective whitelists
pub(crate) fn barcode_counting(assay: &Assay, modality: Modality) -> (IndexMap<RegionId, Whitelist>, usize) {
    let spinner = ProgressBar::with_draw_target(None, ProgressDrawTarget::stderr_with_hz(1))
    .with_style(
        ProgressStyle::with_template(
            "{spinner} Processed {human_pos} reads in {elapsed} ({per_sec}) ...",
        )
        .unwrap(),
    );

    let mut whitelists: IndexMap<_, _> = assay.get_whitelists(modality).into_iter()
        .map(|(k, v)| (k, Whitelist::new(v))).collect();

    let mut num_reads = 0;
    assay
        .get_segments_by_modality(modality)
        .filter(|(_, info)| info.iter().any(|x| x.is_barcode()))
        .for_each(|(read, segment_info)| {
            let is_reverse = read.is_reverse();
            if let Some(mut reader) = read.open() {
                info!("Counting barcodes in read {}...", read.read_id);
                num_reads = 0;
                for fq in reader.records().progress_with(spinner.clone())
                {
                    num_reads += 1;
                    if let Ok(segments) = segment_info.split(&fq.unwrap()) {
                        segments.iter().for_each(|segment| {
                            if segment.is_barcode() {
                                let wl =
                                    whitelists.get_mut(segment.region_id()).expect(&format!(
                                        "whitelist not found for region {}",
                                        segment.region_id()
                                    ));
                                if is_reverse {
                                    wl.count_barcode(&rev_compl(segment.seq));
                                } else {
                                    wl.count_barcode(segment.seq);
                                }
                            }
                        })
                    }
                }
            }
        });
    (whitelists, num_reads)
}


/// A map of oligo species to their frequency in a given library.
#[derive(Debug, Clone)]
pub struct OligoFrequncy(HashMap<Vec<u8>, usize>);

impl Deref for OligoFrequncy {
    type Target = HashMap<Vec<u8>, usize>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for OligoFrequncy {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl FromIterator<(Vec<u8>, usize)> for OligoFrequncy {
    fn from_iter<I: IntoIterator<Item = (Vec<u8>, usize)>>(iter: I) -> Self {
        Self(iter.into_iter().collect())
    }
}

// Implement default for OligoFrequncy
impl Default for OligoFrequncy {
    fn default() -> Self {
        Self::new()
    }
}

impl OligoFrequncy {
    pub fn new() -> Self {
        Self(HashMap::new())
    }

    /// The likelihood of a query oligo being generated by the library.
    /// If the query is present in the library, the likelihood is 1.0.
    /// Otherwise, the likelihood is calculated as
    pub fn likelihood<'a>(
        &'a self,
        query: &'a [u8],
        qual: &[u8],
        n_mismatch: usize,
    ) -> (&'a [u8], f64) {
        if n_mismatch == 0 {
            if self.0.contains_key(query) {
                (query, 1.0)
            } else {
                (query, 0.0)
            }
        } else if n_mismatch == 1 {
            self.likelihood1(query, qual)
        } else if n_mismatch == 2 {
            self.likelihood2(query, qual)
        } else {
            todo!()
        }
    }

    /// The likelihood up to 2 mismatches.
    fn likelihood2<'a>(&'a self, query: &'a [u8], qual: &[u8]) -> (&'a [u8], f64) {
        if self.0.contains_key(query) {
            return (query, 1.0);
        }

        let mut best_option = None;
        let mut total_likelihood = 0.0;
        let mut query_bytes = query.to_vec();

        // Single mismatch loop
        for (pos1, &qv1) in qual.iter().enumerate() {
            let qv1 = qv1.min(BC_MAX_QV);
            let original1 = query_bytes[pos1];

            for base1 in BASE_OPTS {
                if base1 != original1 {
                    query_bytes[pos1] = base1;

                    // Check for 1-mismatch barcode match
                    if let Some((key, raw_count)) = self.0.get_key_value(&query_bytes) {
                        let bc_count = 1 + raw_count;
                        let likelihood = bc_count as f64 * error_probability(qv1);
                        update_best_option(&mut best_option, likelihood, key);
                        total_likelihood += likelihood;
                    }

                    // Loop for the second mismatch
                    for (pos2, &qv2) in qual.iter().enumerate().skip(pos1 + 1) {
                        let qv2 = qv2.min(BC_MAX_QV);
                        let original2 = query_bytes[pos2];

                        for val2 in BASE_OPTS {
                            if val2 != original2 {
                                query_bytes[pos2] = val2;

                                // Check for 2-mismatch barcode match
                                if let Some((key, raw_count)) = self.0.get_key_value(&query_bytes) {
                                    let bc_count = 1 + raw_count;
                                    let likelihood = bc_count as f64
                                        * error_probability(qv1)
                                        * error_probability(qv2);
                                    update_best_option(&mut best_option, likelihood, key);
                                    total_likelihood += likelihood;
                                }
                            }
                        }
                        // Restore original value for second position
                        query_bytes[pos2] = original2;
                    }
                }
            }
            // Restore original value for first position
            query_bytes[pos1] = original1;
        }

        if let Some((best_like, best_bc)) = best_option {
            (best_bc, best_like / total_likelihood)
        } else {
            (query, 0.0)
        }
    }

    /// The likehood up to 1 mismatch.
    fn likelihood1<'a>(&'a self, query: &'a [u8], qual: &[u8]) -> (&'a [u8], f64) {
        if self.0.contains_key(query) {
            return (query, 1.0);
        }

        let mut best_option = None;
        let mut total_likelihood = 0.0;
        let mut query_bytes = query.to_vec();
        for (pos, &qv) in qual.iter().enumerate() {
            let qv = qv.min(BC_MAX_QV);
            let existing = query_bytes[pos];
            for val in BASE_OPTS {
                if val != existing {
                    query_bytes[pos] = val;
                    if let Some((key, raw_count)) = self.0.get_key_value(&query_bytes) {
                        let bc_count = 1 + raw_count;
                        let likelihood = bc_count as f64 * error_probability(qv);
                        update_best_option(&mut best_option, likelihood, key);
                        total_likelihood += likelihood;
                    }
                }
            }
            query_bytes[pos] = existing;
        }

        if let Some((best_like, best_bc)) = best_option {
            (best_bc, best_like / total_likelihood)
        } else {
            (query, 0.0)
        }
    }
}

// Helper function to update the best option
fn update_best_option<'a>(
    best_option: &mut Option<(f64, &'a [u8])>,
    likelihood: f64,
    key: &'a [u8],
) {
    match best_option {
        None => *best_option = Some((likelihood, key)),
        Some(ref old_best) => {
            if old_best.0 < likelihood {
                *best_option = Some((likelihood, key));
            }
        }
    }
}

/// A whitelist manager that handles barcode validation, counting, and prediction.
#[derive(Debug, Clone)]
pub struct Whitelist {
    whitelist_exists: bool,
    barcode_counts: OligoFrequncy,
    mismatch_count: usize,
    pub(crate) total_count: usize,
}

impl Whitelist {
    /// Return the number of barcodes in the whitelist. If the whitelist does not exist, return 0.
    pub fn len(&self) -> usize {
        if self.whitelist_exists {
            self.barcode_counts.len()
        } else {
            0
        }
    }

    pub fn empty() -> Self {
        Self {
            whitelist_exists: false,
            barcode_counts: OligoFrequncy::new(),
            mismatch_count: 0,
            total_count: 0,
        }
    }

    /// Create a new whitelist from an iterator of strings.
    pub fn new<I: IntoIterator<Item = S>, S: Into<Vec<u8>>>(iter: I) -> Self {
        let mut whitelist = Self::empty();
        whitelist.whitelist_exists = true;
        whitelist.barcode_counts = iter.into_iter().map(|x| (x.into(), 0)).collect();
        whitelist
    }

    /// Update the barcode counter with a barcode and its quality scores.
    pub fn count_barcode(&mut self, barcode: &[u8]) {
        if self.whitelist_exists {
            if let Some(count) = self.barcode_counts.get_mut(barcode) {
                *count += 1;
            } else {
                self.mismatch_count += 1;
            }
        } else if barcode.len() > 1 && barcode.iter().all(|x| BASE_OPTS.contains(x)) {
            *self.barcode_counts.entry(barcode.to_vec()).or_insert(0) += 1;
        } else {
            self.mismatch_count += 1;
        }

        self.total_count += 1;
    }

    /// When there should be a whitelist (SequenceType::Onlist), but it does not exist,
    /// predict the whitelist from the barcode counts using the OrdMag algorithm.
    pub fn predict_whitelist(&mut self) {
        if !self.whitelist_exists && !self.barcode_counts.is_empty() {
            info!("Predicting whitelist from {} barcode ...", self.barcode_counts.len());
            let counts = self
                .barcode_counts
                .iter()
                .map(|x| x.1)
                .copied()
                .collect::<Vec<_>>();
            let threshold = compute_cell_filter_threshold(&counts);
            self.barcode_counts = self
                .barcode_counts
                .0
                .clone()
                .into_iter()
                .filter(|x| x.1 >= threshold)
                .collect();
            self.whitelist_exists = true;
            info!(
                "Predicted whitelist contains {} barcodes",
                self.barcode_counts.len()
            );
        }
    }

    pub fn num_seen_barcodes(&self) -> usize {
        self.barcode_counts.values().filter(|&&x| x > 0).count()
    }

    pub fn get_barcode_counts(&self) -> &OligoFrequncy {
        &self.barcode_counts
    }

    pub fn frac_exact_match(&self) -> f64 {
        if self.total_count == 0 {
            0.0
        } else {
            1.0 - (self.mismatch_count as f64 / self.total_count as f64)
        }
    }
}

/// A barcode validator that uses a barcode counter to validate barcodes.
#[derive(Debug, Clone)]
pub struct BarcodeCorrector {
    /// threshold for sum of probability of error on barcode QVs. Barcodes exceeding
    /// this threshold will be marked as not valid.
    max_expected_errors: f64,
    /// if the posterior probability of a correction
    /// exceeds this threshold, the barcode will be corrected.
    bc_confidence_threshold: f64,
    /// The number of mismatches allowed in barcode
    max_mismatch: usize,
}

impl Default for BarcodeCorrector {
    fn default() -> Self {
        Self {
            max_expected_errors: f64::MAX,
            bc_confidence_threshold: 0.975,
            max_mismatch: 1,
        }
    }
}

impl BarcodeCorrector {
    pub fn with_bc_confidence_threshold(mut self, threshold: f64) -> Self {
        self.bc_confidence_threshold = threshold;
        self
    }

    pub fn with_max_missmatch(mut self, max_mismatch: usize) -> Self {
        self.max_mismatch = max_mismatch;
        self
    }
}

#[derive(Copy, Clone, Debug)]
pub enum BarcodeError {
    ExceedExpectedError(f64),
    LowConfidence(f64),
    NoMatch,
}

impl BarcodeCorrector {
    /// Determine if a barcode is valid. A barcode is valid if any of the following conditions are met:
    /// 1) It is in the whitelist and the number of expected errors is less than the max_expected_errors.
    /// 2) It is not in the whitelist, but the number of expected errors is less than the max_expected_errors and the corrected barcode is in the whitelist.
    /// 3) If the whitelist does not exist, the barcode is always valid.
    ///
    /// Return the corrected barcode
    pub fn correct<'a>(
        &'a self,
        barcode_counts: &'a OligoFrequncy,
        barcode: &'a [u8],
        qual: &[u8],
    ) -> Result<&'a [u8], BarcodeError> {
        let expected_errors: f64 = qual.iter().map(|&q| error_probability(q)).sum();
        if expected_errors >= self.max_expected_errors {
            return Err(BarcodeError::ExceedExpectedError(expected_errors));
        }

        let (bc, prob) = barcode_counts.likelihood(barcode, qual, self.max_mismatch);
        if prob <= 0.0 {
            Err(BarcodeError::NoMatch)
        } else if prob >= self.bc_confidence_threshold {
            Ok(bc)
        } else {
            Err(BarcodeError::LowConfidence(prob))
        }
    }
}

/// Convert Illumina quality scores to base-calling error probabilities, i.e.,
/// the probability of an incorrect base call.
#[inline(always)]
fn error_probability(qual: u8) -> f64 {
    let offset = 33.0; // Illumina quality score offset
    10f64.powf(-((qual as f64 - offset) / 10.0))
}

/// Gets the cell barcode from a BAM record.
pub fn get_barcode<R: Record>(record: &R) -> Result<Option<String>> {
    if let Some(data_result) = record.data().get(&Tag::CELL_BARCODE_ID) {
        if let Ok(Value::String(bc)) = data_result {
            match std::str::from_utf8(bc) {
                Ok(s) => {
                    return Ok(Some(s.to_string()));
                }
                Err(e) => {
                    bail!("Failed to parse cell barcode as UTF-8: {}", e)
                }
            }
        }
    }
    Ok(None)
}

pub(crate) fn get_umi<R: Record>(rec: &R) -> Result<Option<String>> {
    Ok(rec
        .data()
        .get(&Tag::UMI_SEQUENCE)
        .transpose()?
        .and_then(|x| match x {
            Value::String(umi) => Some(umi.to_string()),
            _ => None,
        }))
}

/// Compute the knee point from a descending sorted list of counts.
/// The order of the counts is assumed to be descending and is not checked.
/// The knee point is the point on the curve where the second derivative is maximized.
fn get_knee_point(sorted_counts: &[usize]) -> usize {
    // Find the point of maximum curvature on log-log scale
    let mut max_curvature = 0.0;
    let mut knee_idx = 0;

    for i in 1..(sorted_counts.len().min(10000) - 1) {
        if sorted_counts[i] == 0 {
            break;
        }

        let prev = ((i - 1) as f64 + 1.0).ln();
        let curr = ((i) as f64 + 1.0).ln();
        let next = ((i + 1) as f64 + 1.0).ln();

        let prev_val = (sorted_counts[i - 1] as f64).ln();
        let curr_val = (sorted_counts[i] as f64).ln();
        let next_val = (sorted_counts[i + 1] as f64).ln();

        // Approximate second derivative at point i
        let curvature =
            ((next_val - curr_val) / (next - curr)) - ((curr_val - prev_val) / (curr - prev));

        if curvature.abs() > max_curvature {
            max_curvature = curvature.abs();
            knee_idx = i;
        }
    }

    knee_idx
}

/// Get the range of values to use for empty drops background by chemistry type
fn get_empty_drops_range(
    chemistry_description: Option<&str>,
    num_probe_bcs: Option<usize>,
) -> (usize, usize) {
    let n_partitions = match chemistry_description {
        Some("v3LT") => 9000,
        Some("v4") => {
            if let Some(probe_bcs) = num_probe_bcs {
                if probe_bcs > 1 {
                    80000 * probe_bcs
                } else {
                    160000
                }
            } else {
                160000
            }
        }
        _ => {
            if let Some(probe_bcs) = num_probe_bcs {
                if probe_bcs > 1 {
                    45000 * probe_bcs
                } else {
                    90000
                }
            } else {
                90000
            }
        }
    };

    (n_partitions / 2, n_partitions)
}

/// Use the OrdMag algorithm to compute the threshold for the whitelist prediction,
/// where UMI counts are above the threshold are considered as cells (i.e., belongs to the whitelist).
fn compute_cell_filter_threshold(counts: &[usize]) -> usize {
    let nonzero_counts: Vec<_> = counts
        .iter()
        .filter(|&&x| x > 0)
        .copied()
        .sorted()
        .collect();
    let n = nonzero_counts.len();
    let quantile = 0.99;
    let num_bootstrap_samples = 1000;
    let distr = Choose::new(&nonzero_counts).unwrap();

    let num_recovered = (0..num_bootstrap_samples)
        .map(|_| {
            let sample: Vec<_> = distr
                .sample_iter(&mut rand::rng())
                .take(n)
                .copied()
                .sorted()
                .collect();
            estimate_recovered_cells_ordmag(&sample)
        })
        .sum::<usize>() as f64
        / num_bootstrap_samples as f64;

    let baseline_idx = (num_recovered * (1.0 - quantile)).round() as usize;
    let baseline_idx = baseline_idx.min(n.saturating_sub(1));

    let top_n = (0..num_bootstrap_samples)
        .map(|_| {
            let sample: Vec<_> = distr
                .sample_iter(&mut rand::rng())
                .take(n)
                .copied()
                .sorted()
                .collect();
            find_within_ordmag(&sample, baseline_idx)
        })
        .sum::<usize>() as f64
        / num_bootstrap_samples as f64;
    let top_n = top_n.round() as usize;

    nonzero_counts[n - top_n - 1]
}

/// Estimate the number of recovered cells using order-of-magnitude approach.
// The OrdMag algorithm estimates the initial number of recovered cells by calling
// barcodes as cells if their total UMI counts exceed m/10, where m is the 99th
// percentile of the top N barcodes based on total UMI counts. The estimation
// process involves finding a value x that approximates OrdMag(x) by minimizing a
// loss function: (OrgMag(x) - x)^2 / x.
fn estimate_recovered_cells_ordmag(sorted_counts: &[usize]) -> usize {
    let quantile = 0.99;
    let n = sorted_counts.len();

    let mut max = 18;
    let mut num_recoverd = 1;
    std::iter::from_fn(|| {
        max -= 1;
        if max >= 0 {
            let baseline_idx = (num_recoverd as f64 * (1.0 - quantile)).round() as usize;
            let baseline_idx = baseline_idx.min(n.saturating_sub(1));
            let num_obs = find_within_ordmag(sorted_counts, baseline_idx);
            let loss = compute_loss(num_obs, num_recoverd);
            let result = (num_recoverd, loss);
            num_recoverd <<= 1;
            Some(result)
        } else {
            None
        }
    })
    .min_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
    .unwrap()
    .0
}

fn find_within_ordmag(sorted_counts: &[usize], baseline_idx: usize) -> usize {
    let n = sorted_counts.len();
    let baseline = sorted_counts[n - baseline_idx - 1];
    let cutoff = ((0.1 * baseline as f64).round() as usize).max(1);
    n - sorted_counts.binary_search(&cutoff).unwrap_or_else(|x| x)
}

fn compute_loss(num_obs: usize, num_exp: usize) -> f64 {
    (num_obs - num_exp).pow(2) as f64 / num_exp as f64
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty_whitelist() {
        let whitelist = Whitelist::empty();
        assert_eq!(whitelist.num_seen_barcodes(), 0);
        assert_eq!(whitelist.total_count, 0);
        assert_eq!(whitelist.frac_exact_match(), 0.0);
    }

    #[test]
    fn test_new_whitelist() {
        let barcodes = ["ACGTACGT", "TGCATGCA", "GATCGATC"];
        let whitelist = Whitelist::new(barcodes);

        assert!(whitelist.whitelist_exists);
        assert_eq!(whitelist.num_seen_barcodes(), 0); // No barcodes counted yet
        assert_eq!(whitelist.total_count, 0);

        // Check that the whitelist contains the correct barcodes
        let barcode_counts = whitelist.get_barcode_counts();
        for barcode in barcodes {
            assert!(barcode_counts.contains_key(&barcode.as_bytes().to_vec()));
            assert_eq!(barcode_counts[&barcode.as_bytes().to_vec()], 0);
        }
    }

    #[test]
    fn test_find_within_ordmag() {
        let counts = &[50, 60, 70, 80, 90, 100, 700, 800, 900, 1000];

        // With baseline_idx 0 (using max value as baseline)
        // baseline = 1000, cutoff = 100
        assert_eq!(find_within_ordmag(counts, 0), 5);

        // With baseline_idx 1 (using second highest value as baseline)
        // baseline = 900, cutoff = 90
        assert_eq!(find_within_ordmag(counts, 1), 6);
    }
}
